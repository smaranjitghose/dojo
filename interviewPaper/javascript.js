[
    {
      "question": "Explain the event loop in JavaScript. How does it handle asynchronous operations?",
      "answer": "The event loop in JavaScript is responsible for handling asynchronous operations by managing the execution of the call stack and the callback queue. JavaScript has a single-threaded runtime, meaning it can only execute one task at a time. However, it can handle asynchronous operations such as API calls, setTimeout, and event listeners using the event loop. \n\n**How it works:** \n1. When a function is called, it gets pushed onto the call stack. \n2. If the function involves an asynchronous operation (e.g., a setTimeout), it is handed over to the Web APIs, and the function execution continues. \n3. Once the async operation completes, the callback function is pushed to the callback queue. \n4. The event loop continuously checks if the call stack is empty. If it is, it picks up the next function from the callback queue and pushes it onto the call stack for execution. \n\n**Example:**\n```javascript\nconsole.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nconsole.log('End');\n```\n**Output:**\n```\nStart\nEnd\nTimeout\n```\nHere, 'Timeout' executes last because it waits for the call stack to clear before being pushed for execution."
    },
    {
      "question": "What is the difference between synchronous and asynchronous JavaScript? Provide an example.",
      "answer": "In JavaScript, synchronous code executes line by line, blocking further execution until the current operation is complete. Asynchronous code, on the other hand, allows execution to continue while waiting for a task to complete, improving performance. \n\n**Synchronous Example:**\n```javascript\nconsole.log('Step 1');\nconsole.log('Step 2');\nconsole.log('Step 3');\n```\n**Output:**\n```\nStep 1\nStep 2\nStep 3\n```\n\n**Asynchronous Example:**\n```javascript\nconsole.log('Step 1');\nsetTimeout(() => console.log('Step 2'), 1000);\nconsole.log('Step 3');\n```\n**Output:**\n```\nStep 1\nStep 3\nStep 2\n```\nHere, 'Step 3' executes before 'Step 2' because the setTimeout function is asynchronous and runs in the background while the rest of the code executes."
    },
    {
      "question": "How does the 'this' keyword work in JavaScript? Explain with examples.",
      "answer": "The 'this' keyword in JavaScript refers to the context in which a function is executed. Its value depends on how and where the function is called. \n\n**1. Global Context:**\nIn the global scope, 'this' refers to the global object (window in browsers, global in Node.js). \n```javascript\nconsole.log(this); // window (in browsers)\n```\n\n**2. Object Method:**\nInside an object, 'this' refers to the object itself. \n```javascript\nconst obj = {\n  name: 'Yash',\n  greet() {\n    console.log(this.name);\n  }\n};\nobj.greet(); // Output: Yash\n```\n\n**3. Function (Strict Mode):**\nIn strict mode, 'this' inside a function is undefined.\n```javascript\n'use strict';\nfunction test() {\n  console.log(this);\n}\ntest(); // Output: undefined\n```\n\n**4. Arrow Functions:**\nArrow functions do not have their own 'this'; they inherit 'this' from their surrounding scope. \n```javascript\nconst obj = {\n  name: 'Yash',\n  greet: () => console.log(this.name)\n};\nobj.greet(); // Output: undefined\n```\n\n**5. Constructor Functions:**\nWhen using the 'new' keyword, 'this' refers to the newly created object.\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nconst person1 = new Person('Yash');\nconsole.log(person1.name); // Output: Yash\n```"
    }
  ]
  